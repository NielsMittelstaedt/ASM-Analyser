	.arch armv5t // Instruction set für das dieser Code compiliert wurde (armv5t)
	.eabi_attribute 20, 1
	.eabi_attribute 21, 1
	.eabi_attribute 23, 3
	.eabi_attribute 24, 1
	.eabi_attribute 25, 1
	.eabi_attribute 26, 2
	.eabi_attribute 30, 6
	.eabi_attribute 34, 0
	.eabi_attribute 18, 4
	.file	"test.c"
	.text
	.align	2 // alignment required ka
	.global	f // f is globally defined (relative to the linker's scope system)
	.syntax unified
	.arm
	.fpu softvfp // Floating point unit, die verwendet wird.
	.type	f, %function
f:
	----------------------receiving sequence------------------------------
	// Die @'s sind Kommentare vom Compiler mit nützlichen Informationen
	@ args = 0, pretend = 0, frame = 8
	@ frame_needed = 1, uses_anonymous_args = 0
	@ link register save eliminated. // Hier wird z.B. gesagt, dass die receiving and return sequences slightly optimized sind by eliminating the need for a link register
	str	fp, [sp, #-4]!    	// Updated den Stackpointer um -4 und speichert den Wert des Framepointer (r11 in ARM mode) an die neue Adresse
	add	fp, sp, #0			// Fp = sp+0 // (1) speichert den stackpointer (vor der activation record allokation) in den in den frame pointer. 
	sub	sp, sp, #12			// sp = sp-12 // allocates the activation record (Stack Frame) for this routine
	------------------------subroutine body-------------------------------
	str	r0, [fp, #-8]		// Speichert den Wert von r0 an Fp-8
	ldr	r3, [fp, #-8]		// r3 = fp-8
	add	r3, r3, #1			// r3 = r3 + 1
	mov	r0, r3				// r0 = r3, entspricht dem return statement
	--------------------------return sequence-----------------------------
	add	sp, fp, #0			// sp = fp + 0 // Komplement zu oben (1), stellt den stackpointer wieder her
	@ sp needed
	ldr	fp, [sp], #4		// Komplement zur ersten operation, zieht den fp wert wiedeer vom stackpointer
	bx	lr					// springt zur return address from a subroutine zurück und exchange instruction set (je nachdem ob die rücksprungadresse even or odd ist, wird zu thumb gewechselt)
	.size	f, .-f // Größe von f = aktueller Punkt . minus f, lalso die Differenz zwischen hier und dem Label f.
	.ident	"GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0"
	.section	.note.GNU-stack,"",%progbits


	// Zusatz

	push	{fp, lr}								// Push ist kurzform für stmdb SP!, <reglist>
													// und schreibt hier den frampointer und das linkregister (return address from a subroutine) auf den Stack
	add	fp, sp, #4									// fp = sp + 4
	sub	sp, sp, #8									// sp = sp + 8